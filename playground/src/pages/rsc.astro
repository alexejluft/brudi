---
import Layout from '../layouts/Layout.astro';
---

<Layout title="brudi.dev â€” React Server Components Deep Dive">
  <main class="max-w-5xl mx-auto px-6 py-16">
    
    <header class="mb-12">
      <a href="/" class="text-zinc-500 hover:text-zinc-300 text-sm mb-4 inline-block">â† ZurÃ¼ck</a>
      <h1 class="text-4xl font-bold mb-2 page-title">
        React <span class="text-purple-500">Server Components</span>
      </h1>
      <p class="text-zinc-400">
        Nicht "use client" hinklatschen â€” VERSTEHEN warum.
      </p>
    </header>

    <!-- The Big Misconception -->
    <section class="mb-16 p-6 bg-red-500/10 border border-red-500/30 rounded-xl">
      <h2 class="text-red-400 font-medium mb-3">âŒ Das groÃŸe MissverstÃ¤ndnis</h2>
      <p class="text-zinc-300 mb-4">
        <strong>"RSC ist Server-Side Rendering 2.0"</strong> â€” FALSCH.
      </p>
      <p class="text-zinc-400">
        SSR und RSC sind <strong>orthogonal</strong>. Sie lÃ¶sen verschiedene Probleme und kÃ¶nnen zusammen ODER getrennt verwendet werden.
      </p>
    </section>

    <!-- Mental Model -->
    <section class="mb-16 p-6 bg-purple-500/10 border border-purple-500/30 rounded-xl">
      <h2 class="text-purple-400 font-medium mb-3">ğŸ§  Das mentale Modell</h2>
      <div class="grid md:grid-cols-2 gap-6 mt-4">
        <div class="bg-zinc-900/50 border border-zinc-800 rounded-xl p-4">
          <h3 class="text-orange-400 font-medium mb-2">SSR (Server-Side Rendering)</h3>
          <div class="text-sm space-y-2 text-zinc-300">
            <p>React â†’ <strong>HTML</strong> â†’ Browser</p>
            <p class="text-zinc-500">â†“</p>
            <p>Browser lÃ¤dt <strong>ALLEN Code</strong></p>
            <p class="text-zinc-500">â†“</p>
            <p>Hydration (Event Handlers anbringen)</p>
          </div>
          <p class="text-red-400 text-sm mt-4">âŒ "Hydration Tax" â€” alles runterladen</p>
        </div>
        
        <div class="bg-zinc-900/50 border border-zinc-800 rounded-xl p-4">
          <h3 class="text-purple-400 font-medium mb-2">RSC (Server Components)</h3>
          <div class="text-sm space-y-2 text-zinc-300">
            <p>Server Components â†’ <strong>Serialisierter React-Baum</strong></p>
            <p class="text-zinc-500">â†“</p>
            <p>Browser lÃ¤dt <strong>nur Client Component Code</strong></p>
            <p class="text-zinc-500">â†“</p>
            <p>Rekonstruiert React-Baum aus Stream</p>
          </div>
          <p class="text-green-400 text-sm mt-4">âœ… Kein Code fÃ¼r Server Components im Bundle</p>
        </div>
      </div>
    </section>

    <!-- What RSC Actually Outputs -->
    <section class="mb-16">
      <h2 class="text-2xl font-semibold mb-6 text-zinc-200">
        Was RSC WIRKLICH ausgibt
      </h2>
      
      <div class="bg-zinc-900/50 border border-zinc-800 rounded-xl p-6">
        <p class="text-zinc-300 mb-4">
          RSC gibt <strong>kein HTML</strong> aus. Es gibt einen <strong>serialisierten React-Baum</strong> aus:
        </p>
        
        <div class="bg-zinc-800 rounded p-4 text-sm font-mono overflow-x-auto">
          <p class="text-green-400 mb-2"># RSC Wire Format</p>
          <p class="text-blue-400">M1:{`{"id":"./ClientComponent.js","chunks":["client1"]}`}</p>
          <p class="text-yellow-400">J0:{`["$","@1",null,{"children":["$","span",null,{"children":"Hello"}]}]`}</p>
        </div>
        
        <div class="mt-4 space-y-2 text-sm">
          <p class="text-zinc-300"><code class="text-blue-400">M</code> Zeilen = Module References (Client Components)</p>
          <p class="text-zinc-300"><code class="text-yellow-400">J</code> Zeilen = React Element Trees</p>
          <p class="text-zinc-300"><code class="text-purple-400">@1</code> = Referenz zu Client Component M1</p>
        </div>
      </div>
      
      <div class="mt-6 p-4 bg-yellow-500/10 border border-yellow-500/30 rounded-lg">
        <p class="text-yellow-400 text-sm">
          <strong>Warum nicht einfach HTML?</strong> Mit dem RSC-Format kann React den Baum <strong>rekonstruieren</strong> â€” 
          State bleibt erhalten, Updates sind minimal, es ist ein normales React-Update!
        </p>
      </div>
    </section>

    <!-- The Bundler Magic -->
    <section class="mb-16">
      <h2 class="text-2xl font-semibold mb-6 text-zinc-200">
        Die Bundler-Magie
      </h2>
      
      <div class="bg-zinc-900/50 border border-zinc-800 rounded-xl p-6">
        <p class="text-zinc-300 mb-4">
          Wenn ein Server Component ein Client Component importiert, passiert etwas Interessantes:
        </p>
        
        <div class="grid md:grid-cols-2 gap-4 mb-6">
          <div class="bg-zinc-800 rounded p-4">
            <p class="text-sm text-zinc-400 mb-2">Was du schreibst:</p>
            <pre class="text-sm font-mono text-blue-300">import Button from './Button'</pre>
          </div>
          <div class="bg-zinc-800 rounded p-4">
            <p class="text-sm text-zinc-400 mb-2">Was der Bundler macht:</p>
            <pre class="text-sm font-mono text-green-300">{`{
  $$typeof: Symbol(react.module.reference),
  filename: "./Button.client.js",
  name: "default"
}`}</pre>
          </div>
        </div>
        
        <p class="text-zinc-400 text-sm">
          <strong>Nicht die Funktion</strong> â€” nur eine <strong>Referenz</strong>! 
          Der Server kennt den Client-Code nicht, er weiÃŸ nur, dass es ihn gibt.
        </p>
      </div>
    </section>

    <!-- Why No Hooks -->
    <section class="mb-16">
      <h2 class="text-2xl font-semibold mb-6 text-zinc-200">
        WARUM keine Hooks in Server Components?
      </h2>
      
      <div class="space-y-4">
        <div class="bg-zinc-900/50 border border-zinc-800 rounded-xl p-4 flex items-start gap-4">
          <div class="text-2xl">ğŸ”„</div>
          <div>
            <h3 class="text-blue-400 font-medium">useState</h3>
            <p class="text-zinc-400 text-sm">Wo soll der State leben? Server Components werden <strong>einmal</strong> ausgefÃ¼hrt und sind dann fertig. Es gibt keinen Browser, der State halten kann.</p>
          </div>
        </div>
        
        <div class="bg-zinc-900/50 border border-zinc-800 rounded-xl p-4 flex items-start gap-4">
          <div class="text-2xl">âš¡</div>
          <div>
            <h3 class="text-green-400 font-medium">useEffect</h3>
            <p class="text-zinc-400 text-sm">Welchen DOM? Es gibt keinen! Effects laufen <strong>nach dem Rendern im Browser</strong> â€” Server Components rendern auf dem Server.</p>
          </div>
        </div>
        
        <div class="bg-zinc-900/50 border border-zinc-800 rounded-xl p-4 flex items-start gap-4">
          <div class="text-2xl">ğŸ¯</div>
          <div>
            <h3 class="text-purple-400 font-medium">Das Design</h3>
            <p class="text-zinc-400 text-sm">Server Components sind <strong>stateless und effectless by design</strong>. Nicht als EinschrÃ¤nkung â€” als Feature!</p>
          </div>
        </div>
      </div>
    </section>

    <!-- Props Must Be Serializable -->
    <section class="mb-16">
      <h2 class="text-2xl font-semibold mb-6 text-zinc-200">
        Props mÃ¼ssen serialisierbar sein
      </h2>
      
      <div class="grid md:grid-cols-2 gap-6">
        <div class="bg-red-500/10 border border-red-500/30 rounded-xl p-6">
          <h3 class="text-red-400 font-medium mb-3">âŒ Das geht NICHT</h3>
          <div class="bg-zinc-900 rounded p-4 text-sm font-mono">
            <pre class="text-zinc-300">{`// Server Component
function ServerPage() {
  return (
    <ClientButton 
      onClick={() => alert('hi')}
    />
  )
}`}</pre>
          </div>
          <p class="text-zinc-400 text-sm mt-3">
            Funktionen sind nicht JSON-serialisierbar!
          </p>
        </div>
        
        <div class="bg-green-500/10 border border-green-500/30 rounded-xl p-6">
          <h3 class="text-green-400 font-medium mb-3">âœ… Das geht</h3>
          <div class="bg-zinc-900 rounded p-4 text-sm font-mono">
            <pre class="text-zinc-300">{`// Client Component
'use client'
function ClientButton() {
  return (
    <button 
      onClick={() => alert('hi')}
    >Click</button>
  )
}`}</pre>
          </div>
          <p class="text-zinc-400 text-sm mt-3">
            Event Handler leben im Client Component!
          </p>
        </div>
      </div>
      
      <div class="mt-6 p-4 bg-blue-500/10 border border-blue-500/30 rounded-lg">
        <p class="text-blue-400 text-sm">
          <strong>Aber:</strong> Client Components kÃ¶nnen Funktionen an <strong>andere Client Components</strong> Ã¼bergeben. 
          Die EinschrÃ¤nkung gilt nur an der Serverâ†’Client Grenze.
        </p>
      </div>
    </section>

    <!-- Composition Pattern -->
    <section class="mb-16">
      <h2 class="text-2xl font-semibold mb-6 text-zinc-200">
        Das Composition Pattern
      </h2>
      
      <div class="bg-zinc-900/50 border border-zinc-800 rounded-xl p-6">
        <p class="text-zinc-300 mb-4">
          Client Components kÃ¶nnen keine Server Components <strong>importieren</strong>. 
          Aber sie kÃ¶nnen Server Components als <strong>children</strong> erhalten!
        </p>
        
        <div class="bg-zinc-800 rounded p-4 text-sm font-mono mb-4">
          <pre class="text-zinc-300">{`// ServerPage.server.js
import ClientWrapper from './ClientWrapper'
import ServerContent from './ServerContent'

function ServerPage() {
  return (
    <ClientWrapper>
      <ServerContent />  {/* âœ… Als children! */}
    </ClientWrapper>
  )
}`}</pre>
        </div>
        
        <p class="text-zinc-400 text-sm">
          Der Trick: <code>ServerContent</code> wird vom Server gerendert, <strong>bevor</strong> es an den Client gesendet wird.
          Der Client sieht nur den fertigen Output als props.
        </p>
      </div>
    </section>

    <!-- Suspense & Streaming -->
    <section class="mb-16">
      <h2 class="text-2xl font-semibold mb-6 text-zinc-200">
        Suspense & Streaming
      </h2>
      
      <div class="bg-zinc-900/50 border border-zinc-800 rounded-xl p-6">
        <p class="text-zinc-300 mb-4">
          RSC unterstÃ¼tzt <strong>Streaming</strong>. Async Server Components kÃ¶nnen Suspense Boundaries haben:
        </p>
        
        <div class="space-y-3">
          <div class="flex items-center gap-3">
            <div class="w-8 h-8 rounded-full bg-purple-500/30 flex items-center justify-center text-sm">1</div>
            <p class="text-zinc-300 text-sm">Server startet Rendering, trifft auf async Component</p>
          </div>
          <div class="flex items-center gap-3">
            <div class="w-8 h-8 rounded-full bg-purple-500/30 flex items-center justify-center text-sm">2</div>
            <p class="text-zinc-300 text-sm">Server sendet Placeholder (Suspense Fallback)</p>
          </div>
          <div class="flex items-center gap-3">
            <div class="w-8 h-8 rounded-full bg-purple-500/30 flex items-center justify-center text-sm">3</div>
            <p class="text-zinc-300 text-sm">Client zeigt Fallback sofort an</p>
          </div>
          <div class="flex items-center gap-3">
            <div class="w-8 h-8 rounded-full bg-purple-500/30 flex items-center justify-center text-sm">4</div>
            <p class="text-zinc-300 text-sm">Async Operation fertig â†’ Server streamt fertigen Content</p>
          </div>
          <div class="flex items-center gap-3">
            <div class="w-8 h-8 rounded-full bg-purple-500/30 flex items-center justify-center text-sm">5</div>
            <p class="text-zinc-300 text-sm">Client ersetzt Placeholder â†’ Kein Flicker!</p>
          </div>
        </div>
      </div>
    </section>

    <!-- When to Use What -->
    <section class="mb-16">
      <h2 class="text-2xl font-semibold mb-6 text-zinc-200">
        Wann was verwenden?
      </h2>
      
      <div class="grid md:grid-cols-2 gap-6">
        <div class="bg-purple-500/10 border border-purple-500/30 rounded-xl p-6">
          <h3 class="text-purple-400 font-medium mb-3">Server Component</h3>
          <ul class="space-y-2 text-sm text-zinc-300">
            <li>âœ… Data Fetching (DB, APIs)</li>
            <li>âœ… GroÃŸe Dependencies (markdown parser, etc.)</li>
            <li>âœ… Sensitive Logik (API Keys, DB Queries)</li>
            <li>âœ… Statischer Content</li>
          </ul>
        </div>
        
        <div class="bg-blue-500/10 border border-blue-500/30 rounded-xl p-6">
          <h3 class="text-blue-400 font-medium mb-3">Client Component</h3>
          <ul class="space-y-2 text-sm text-zinc-300">
            <li>âœ… InteraktivitÃ¤t (onClick, onChange)</li>
            <li>âœ… State (useState, useReducer)</li>
            <li>âœ… Effects (useEffect)</li>
            <li>âœ… Browser APIs (localStorage, etc.)</li>
          </ul>
        </div>
      </div>
    </section>

    <!-- What I learned -->
    <section class="mb-16 p-6 bg-green-500/10 border border-green-500/30 rounded-xl">
      <h2 class="text-green-400 font-medium mb-3">âœ… Was ich WIRKLICH verstanden habe</h2>
      <ul class="space-y-2 text-zinc-300 text-sm">
        <li>â€¢ <strong>RSC â‰  SSR</strong> â€” RSC produziert serialisierte React-BÃ¤ume, nicht HTML</li>
        <li>â€¢ <strong>Das Wire Format</strong> ist streambar und erlaubt progressive Updates</li>
        <li>â€¢ <strong>Keine Hooks</strong> weil Server Components stateless & effectless sind â€” by design</li>
        <li>â€¢ <strong>Module References</strong> â€” Bundler ersetzt Client Component Imports durch Referenzen</li>
        <li>â€¢ <strong>Props mÃ¼ssen serialisierbar sein</strong> an der Serverâ†’Client Grenze</li>
        <li>â€¢ <strong>Composition</strong> â€” Server Components als children Ã¼bergeben, nicht importieren</li>
      </ul>
    </section>

    <nav class="flex gap-4 pt-8 border-t border-zinc-800">
      <a href="/typescript" class="text-purple-400 hover:text-purple-300">â† TypeScript</a>
      <a href="/" class="text-purple-400 hover:text-purple-300 ml-auto">Home â†’</a>
    </nav>

  </main>
</Layout>
